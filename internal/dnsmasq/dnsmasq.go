package dnsmasq

import (
	"bufio"
	"context"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

type DNSMasq struct {
	mu         sync.Mutex
	configPath string
	hostsPath  string
	interfaces []string
	upstream   []string
}

func New(configPath, hostsPath string, interfaces []string, upstream []string) *DNSMasq {
	return &DNSMasq{
		configPath: configPath,
		hostsPath:  hostsPath,
		interfaces: interfaces,
		upstream:   upstream,
	}
}

func (d *DNSMasq) WriteConfig() error {
	d.mu.Lock()
	defer d.mu.Unlock()

	dir := filepath.Dir(d.configPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	var config strings.Builder

	config.WriteString("# WireGuard VPN dnsmasq configuration\n")
	config.WriteString("# Generated by wg-self-serve\n\n")

	config.WriteString("# Required for systemd-resolved compatibility\n")
	config.WriteString("bind-dynamic\n")
	for _, iface := range d.interfaces {
		config.WriteString(fmt.Sprintf("interface=%s\n", iface))
	}
	config.WriteString("\n")

	config.WriteString("# Upstream DNS servers\n")
	for _, dns := range d.upstream {
		config.WriteString(fmt.Sprintf("server=%s\n", dns))
	}
	config.WriteString("\n")

	config.WriteString("# Don't use /etc/resolv.conf\n")
	config.WriteString("no-resolv\n\n")

	config.WriteString("# Cache settings\n")
	config.WriteString("cache-size=1000\n")

	if err := os.WriteFile(d.configPath, []byte(config.String()), 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	if _, err := os.Stat(d.hostsPath); os.IsNotExist(err) {
		if err := os.WriteFile(d.hostsPath, []byte("# VPN DNS mappings\n# Generated by wg-self-serve\n# Format: address=/hostname/ip\n"), 0644); err != nil {
			return fmt.Errorf("failed to create hosts file: %w", err)
		}
	}

	return nil
}

func (d *DNSMasq) GetMappings() (map[string]string, error) {
	d.mu.Lock()
	defer d.mu.Unlock()

	mappings := make(map[string]string)

	file, err := os.Open(d.hostsPath)
	if err != nil {
		if os.IsNotExist(err) {
			return mappings, nil
		}
		return nil, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse address=/hostname/ip format
		if strings.HasPrefix(line, "address=/") {
			parts := strings.Split(strings.TrimPrefix(line, "address=/"), "/")
			if len(parts) >= 2 {
				hostname := parts[0]
				ip := parts[1]
				mappings[hostname] = ip
			}
		}
	}

	return mappings, scanner.Err()
}

func (d *DNSMasq) SetMappings(mappings map[string]string) error {
	d.mu.Lock()
	defer d.mu.Unlock()

	var hosts strings.Builder
	hosts.WriteString("# VPN DNS mappings\n")
	hosts.WriteString("# Generated by wg-self-serve\n\n")

	for hostname, ip := range mappings {
		hosts.WriteString(fmt.Sprintf("address=/%s/%s\n", hostname, ip))
	}

	if err := os.WriteFile(d.hostsPath, []byte(hosts.String()), 0644); err != nil {
		return fmt.Errorf("failed to write hosts file: %w", err)
	}

	return nil
}

func (d *DNSMasq) AddMapping(hostname, ip string) error {
	mappings, err := d.GetMappings()
	if err != nil {
		return err
	}

	mappings[hostname] = ip
	return d.SetMappings(mappings)
}

func (d *DNSMasq) RemoveMapping(hostname string) error {
	mappings, err := d.GetMappings()
	if err != nil {
		return err
	}

	delete(mappings, hostname)
	return d.SetMappings(mappings)
}

func (d *DNSMasq) Reload() error {
	cmd := exec.Command("systemctl", "restart", "dnsmasq")
	return cmd.Run()
}

func (d *DNSMasq) Start() error {
	cmd := exec.Command("systemctl", "start", "dnsmasq")
	return cmd.Run()
}

func (d *DNSMasq) Stop() error {
	cmd := exec.Command("systemctl", "stop", "dnsmasq")
	return cmd.Run()
}

func (d *DNSMasq) Enable() error {
	cmd := exec.Command("systemctl", "enable", "dnsmasq")
	return cmd.Run()
}

type Status struct {
	Running      bool
	Enabled      bool
	ConfigExists bool
	Error        string
}

func (d *DNSMasq) Status() Status {
	status := Status{}

	cmd := exec.Command("systemctl", "is-active", "dnsmasq")
	if err := cmd.Run(); err == nil {
		status.Running = true
	}

	cmd = exec.Command("systemctl", "is-enabled", "dnsmasq")
	if err := cmd.Run(); err == nil {
		status.Enabled = true
	}

	if _, err := os.Stat(d.configPath); err == nil {
		status.ConfigExists = true
	}

	return status
}

func (d *DNSMasq) UpdateUpstream(servers []string) {
	d.mu.Lock()
	defer d.mu.Unlock()
	d.upstream = servers
}

// ResolveWith resolves a hostname against a specific DNS server
func ResolveWith(hostname, dnsServer string) (string, error) {
	if !strings.Contains(dnsServer, ":") {
		dnsServer = dnsServer + ":53"
	}

	resolver := &net.Resolver{
		PreferGo: true,
		Dial: func(ctx context.Context, network, address string) (net.Conn, error) {
			d := net.Dialer{Timeout: 2 * time.Second}
			return d.DialContext(ctx, "udp", dnsServer)
		},
	}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	ips, err := resolver.LookupIP(ctx, "ip4", hostname)
	if err != nil {
		return "", err
	}
	if len(ips) == 0 {
		return "", fmt.Errorf("no A record found")
	}
	return ips[0].String(), nil
}

// ResolveAllWith resolves multiple hostnames in parallel against a DNS server
func ResolveAllWith(hostnames []string, dnsServer string) map[string]string {
	results := make(map[string]string)
	var mu sync.Mutex
	var wg sync.WaitGroup

	for _, h := range hostnames {
		wg.Add(1)
		go func(hostname string) {
			defer wg.Done()
			ip, err := ResolveWith(hostname, dnsServer)
			mu.Lock()
			if err != nil {
				results[hostname] = ""
			} else {
				results[hostname] = ip
			}
			mu.Unlock()
		}(h)
	}

	wg.Wait()
	return results
}
