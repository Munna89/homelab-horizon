package dnsmasq

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGetMappings_ParsesAddressFormat(t *testing.T) {
	tempDir := t.TempDir()
	hostsPath := filepath.Join(tempDir, "hosts")

	content := `# VPN DNS mappings
# Generated by wg-self-serve

address=/app.example.com/192.168.1.50
address=/api.example.com/192.168.1.51
address=/grafana.local/10.0.0.100

# This is a comment
address=/with-dash.example.com/192.168.1.52
`
	if err := os.WriteFile(hostsPath, []byte(content), 0644); err != nil {
		t.Fatalf("failed to write test hosts file: %v", err)
	}

	d := New("/tmp/dnsmasq.conf", hostsPath, nil, nil)
	mappings, err := d.GetMappings()
	if err != nil {
		t.Fatalf("GetMappings() error = %v", err)
	}

	expected := map[string]string{
		"app.example.com":       "192.168.1.50",
		"api.example.com":       "192.168.1.51",
		"grafana.local":         "10.0.0.100",
		"with-dash.example.com": "192.168.1.52",
	}

	for hostname, wantIP := range expected {
		t.Run(hostname, func(t *testing.T) {
			got, exists := mappings[hostname]
			if !exists {
				t.Errorf("mapping for %s not found", hostname)
				return
			}
			if got != wantIP {
				t.Errorf("mappings[%s] = %s, want %s", hostname, got, wantIP)
			}
		})
	}

	if len(mappings) != 4 {
		t.Errorf("expected 4 mappings, got %d", len(mappings))
	}
}

func TestGetMappings_EmptyFile(t *testing.T) {
	tempDir := t.TempDir()
	hostsPath := filepath.Join(tempDir, "hosts")

	content := `# Just comments
# No actual mappings
`
	if err := os.WriteFile(hostsPath, []byte(content), 0644); err != nil {
		t.Fatalf("failed to write test hosts file: %v", err)
	}

	d := New("/tmp/dnsmasq.conf", hostsPath, nil, nil)
	mappings, err := d.GetMappings()
	if err != nil {
		t.Fatalf("GetMappings() error = %v", err)
	}

	if len(mappings) != 0 {
		t.Errorf("expected 0 mappings, got %d", len(mappings))
	}
}

func TestGetMappings_NonExistentFile(t *testing.T) {
	d := New("/tmp/dnsmasq.conf", "/nonexistent/path/hosts", nil, nil)
	mappings, err := d.GetMappings()
	if err != nil {
		t.Fatalf("GetMappings() should not error for nonexistent file, got %v", err)
	}

	if len(mappings) != 0 {
		t.Errorf("expected 0 mappings for nonexistent file, got %d", len(mappings))
	}
}

func TestSetMappings(t *testing.T) {
	tempDir := t.TempDir()
	hostsPath := filepath.Join(tempDir, "hosts")

	d := New("/tmp/dnsmasq.conf", hostsPath, nil, nil)

	input := map[string]string{
		"app.example.com": "192.168.1.50",
		"api.example.com": "192.168.1.51",
	}

	if err := d.SetMappings(input); err != nil {
		t.Fatalf("SetMappings() error = %v", err)
	}

	got, err := d.GetMappings()
	if err != nil {
		t.Fatalf("GetMappings() error = %v", err)
	}

	if len(got) != 2 {
		t.Errorf("expected 2 mappings, got %d", len(got))
	}

	for hostname, ip := range input {
		if got[hostname] != ip {
			t.Errorf("mappings[%s] = %s, want %s", hostname, got[hostname], ip)
		}
	}
}

func TestAddMapping(t *testing.T) {
	tempDir := t.TempDir()
	hostsPath := filepath.Join(tempDir, "hosts")

	if err := os.WriteFile(hostsPath, []byte(""), 0644); err != nil {
		t.Fatalf("failed to write test hosts file: %v", err)
	}

	d := New("/tmp/dnsmasq.conf", hostsPath, nil, nil)

	if err := d.AddMapping("new.example.com", "10.0.0.1"); err != nil {
		t.Fatalf("AddMapping() error = %v", err)
	}

	mappings, _ := d.GetMappings()
	if mappings["new.example.com"] != "10.0.0.1" {
		t.Errorf("AddMapping failed: got %s, want 10.0.0.1", mappings["new.example.com"])
	}
}

func TestRemoveMapping(t *testing.T) {
	tempDir := t.TempDir()
	hostsPath := filepath.Join(tempDir, "hosts")

	content := `address=/keep.example.com/192.168.1.1
address=/remove.example.com/192.168.1.2
`
	if err := os.WriteFile(hostsPath, []byte(content), 0644); err != nil {
		t.Fatalf("failed to write test hosts file: %v", err)
	}

	d := New("/tmp/dnsmasq.conf", hostsPath, nil, nil)

	if err := d.RemoveMapping("remove.example.com"); err != nil {
		t.Fatalf("RemoveMapping() error = %v", err)
	}

	mappings, _ := d.GetMappings()
	if _, exists := mappings["remove.example.com"]; exists {
		t.Error("RemoveMapping failed: mapping still exists")
	}
	if mappings["keep.example.com"] != "192.168.1.1" {
		t.Error("RemoveMapping removed wrong mapping")
	}
}

func TestWriteConfig(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "dnsmasq.conf")
	hostsPath := filepath.Join(tempDir, "hosts")

	d := New(configPath, hostsPath, []string{"wg0", "eth0"}, []string{"8.8.8.8", "1.1.1.1"})

	if err := d.WriteConfig(); err != nil {
		t.Fatalf("WriteConfig() error = %v", err)
	}

	content, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("failed to read config file: %v", err)
	}

	configStr := string(content)

	expectedDirectives := []string{
		"interface=wg0",
		"interface=eth0",
		"server=8.8.8.8",
		"server=1.1.1.1",
		"bind-dynamic",
		"no-resolv",
		"cache-size=1000",
	}

	for _, directive := range expectedDirectives {
		if !strings.Contains(configStr, directive) {
			t.Errorf("config should contain %q", directive)
		}
	}

	if _, err := os.Stat(hostsPath); os.IsNotExist(err) {
		t.Error("hosts file should be created")
	}
}

func TestNew(t *testing.T) {
	d := New("/etc/dnsmasq.d/wg.conf", "/etc/dnsmasq.d/hosts", []string{"wg0"}, []string{"8.8.8.8"})

	if d == nil {
		t.Fatal("New() returned nil")
	}
}

func TestUpdateUpstream(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "dnsmasq.conf")
	hostsPath := filepath.Join(tempDir, "hosts")

	d := New(configPath, hostsPath, nil, []string{"8.8.8.8"})
	d.UpdateUpstream([]string{"1.1.1.1", "9.9.9.9"})

	if err := d.WriteConfig(); err != nil {
		t.Fatalf("WriteConfig() error = %v", err)
	}

	content, _ := os.ReadFile(configPath)
	configStr := string(content)

	if !strings.Contains(configStr, "server=1.1.1.1") {
		t.Error("config should contain updated upstream 1.1.1.1")
	}
	if !strings.Contains(configStr, "server=9.9.9.9") {
		t.Error("config should contain updated upstream 9.9.9.9")
	}
}
